<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>粒子线条canvas效果</title>
	<style>
		#J_dotLine{
			display: block;
			margin: 0 auto;
		}
	</style>
</head>
<body>
	<!-- 
		**canvasAPI
			https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API
		**教程
		1、http://www.qdfuns.com/notes/33868/7393fd13b05cac36799c179cdd81129b.html
		2、http://www.cnblogs.com/axes/p/4960171.html
		**原理
		1、生成多个随机移动的点
		2、当点与点之间的距离小于一定值时产生连线，大于这个值连线消失
		3、鼠标放上去确定一个点
		4、鼠标点有磁性
		**注意点
		1、设置画布内元素的随机分布占满画布，请用Math.floor(Math.random()*c.width)//c.width是画布尺寸
		2、如何让canvas动起来请使用requestAnimationFrame （http://blog.csdn.net/jiulan1996/article/details/51291087）
		3、continue关键字（http://www.cnblogs.com/jiechn/p/3989849.html）
		4、如何确定两点间的距离？三角形两边平方和 = 第三边的平方
		5、鼠标上移汇聚每个点效果
		6、这个点困扰了很久：animate要使用window的requestAnimationFrame，如果方法写在原型链上，this指向一直指window，方法就是把这些方法想写到构造函数里，而不是写在原型链上。
	 -->
	<canvas id="J_dotLine" style="background-color: #F7F7F7;"></canvas>
	<script>
		;(function(window,document){
			function Dotline(option){
				this.opt = this.extend({
					dom:'J_dotLine',//画布id
					cw:1000,//画布宽
					ch:500,//画布高
					ds:100,//点的个数
					r:0.5,//圆点半径
					dis:100//触发连线的距离
				},option);
				this.c = document.getElementById(this.opt.dom);//canvas元素id
				this.ctx = this.c.getContext('2d');
				this.c.width = this.opt.cw;//canvas宽
				this.c.height = this.opt.ch;//canvas高
				this.dotSum = this.opt.ds;//点的数量
				this.radius = this.opt.r;//圆点的半径
				this.disMax = this.opt.dis*this.opt.dis;//点与点触发连线的间距		
				this.dots = [];
				//requestAnimationFrame控制canvas动画
				var RAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
				            window.setTimeout(callback, 1000 / 60);
				        };
				var _self = this;
				//增加鼠标效果
				var mousedot = {x:null,y:null,label:'mouse'};
				this.c.onmousemove = function(e){
					var e = e || window.event;
					mousedot.x = e.clientX - _self.c.offsetLeft;
					mousedot.y = e.clientY - _self.c.offsetTop;
				};
				this.c.onmouseout = function(e){
					mousedot.x = null;
					mousedot.y = null;
				}
				//控制动画
				this.animate = function(){
					_self.ctx.clearRect(0, 0, _self.c.width, _self.c.height);
					_self.drawLine([mousedot].concat(_self.dots));
					RAF(_self.animate);
				};
			}
			//合并配置项，es6直接使用obj.assign();
			Dotline.prototype.extend = function(o,e){
				for(var key in e){
					if(e[key]){
						o[key]=e[key]
					}
				}
				return o;
			};
			//画点
			Dotline.prototype.addDots = function(){
				var dot;
				for(var i=0; i<this.dotSum; i++){//参数
					dot = {
						x : Math.floor(Math.random()*this.c.width)-this.radius,
						y : Math.floor(Math.random()*this.c.height)-this.radius,
						ax : (Math.random() * 2 - 1) / 1.5,
						ay : (Math.random() * 2 - 1) / 1.5
					}
					this.dots.push(dot);
				}
			};
			//点运动
			Dotline.prototype.move = function(dot){
				dot.x += dot.ax;
				dot.y += dot.ay;
				//点碰到边缘返回
				dot.ax *= (dot.x>(this.c.width-this.radius)||dot.x<this.radius)?-1:1;
				dot.ay *= (dot.y>(this.c.height-this.radius)||dot.y<this.radius)?-1:1;
				//绘制点
				this.ctx.beginPath();
				this.ctx.arc(dot.x, dot.y, this.radius, 0, Math.PI*2, true);
				this.ctx.stroke();
			};
			//点之间画线
			Dotline.prototype.drawLine = function(dots){
				var nowDot;
				var _that = this;
				//自己的思路：遍历两次所有的点，比较点之间的距离，函数的触发放在animate里
				this.dots.forEach(function(dot){
					
					_that.move(dot);
					for(var j=0; j<dots.length; j++){
						nowDot = dots[j];
						if(nowDot===dot||nowDot.x===null||nowDot.y===null) continue;//continue跳出当前循环开始新的循环
						var dx = dot.x - nowDot.x,//别的点坐标减当前点坐标
							dy = dot.y - nowDot.y;
						var dc = dx*dx + dy*dy;
						if(Math.sqrt(dc)>Math.sqrt(_that.disMax)) continue;
						// 如果是鼠标，则让粒子向鼠标的位置移动
						if (nowDot.label && Math.sqrt(dc) >Math.sqrt(_that.disMax)/2) {
							dot.x -= dx * 0.02;
							dot.y -= dy * 0.02;
						}
						var ratio;
						ratio = (_that.disMax - dc) / _that.disMax;

						_that.ctx.beginPath();
						_that.ctx.lineWidth = ratio / 2;
	          			_that.ctx.strokeStyle = 'rgba(0,0,0,' + (ratio + 0.2) + ')';
						_that.ctx.moveTo(dot.x, dot.y);
						_that.ctx.lineTo(nowDot.x, nowDot.y);
						_that.ctx.stroke();//不描边看不出效果

						//dots.splice(dots.indexOf(dot), 1);
					}
				});
			};
			//开始动画
			Dotline.prototype.start = function(){
				var _that = this;
				this.addDots();
				setTimeout(function() {
				     _that.animate();
				}, 100);
			}
			window.Dotline = Dotline;
		}(window,document));
		//调用
		window.onload = function(){
			var dotline = new Dotline({
				dom:'J_dotLine',//画布id
				cw:1000,//画布宽
				ch:500,//画布高
				ds:100,//点的个数
				r:0.5,//圆点半径
				dis:100//触发连线的距离
			}).start();
		}
	</script>
</body>
</html>