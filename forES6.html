<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>for ES6</title>
</head>
<body>
	<script>
		/*
		var a = [];
		for (let i = 0; i < 10; i++) {
		  a[i] = function () {
		    console.log(i);
		  };
		}
		a[6]();
		console.log(a);
		
		

		//从js的错误处理机制切入，理解es6的promise
		try{
			console.log(fdsafds);
		}catch(error){
			alert(error.message);
			//错误被放进这里打印出来，而不是在浏览器的开发者工具里红字显示。我们应该把所有可能会抛出错误的代码都放在 try 语句块中，而把那些用于错误处理的代码放在 catch 块中
			if (error instanceof TypeError){
				//处理类型错误
				alert(error.constructor.name);
			} else if (error instanceof ReferenceError){
				//处理引用错误
				alert(error.constructor.name);
			} else {
				//处理其他类型的错误
				alert(error.constructor.name);
			}
		}
		*/
		// throw 操作符，用于随时抛出自定义错误。抛出错误时，必须要给 throw 操作符指定一个值，这个值是什么类型，没有要求
		//比如：我们写bind函数模拟，如果调用_bind()的不是一个函数，那就可以主动抛出一个错误，像浏览器一样显示红字报错：
		function testThrow(val){
			if(typeof val !== 'string'){
				throw new Error('testThrow():arguments need string')
			}
		};
		try{
			testThrow({});
		}catch(error){
			console.log('err_msg=='+error.message);
		}
		
		console.log('错误被捕获了，代码可以继执行');
		//try-catch用于捕获错误，throw用于主动抛出错误

		//回调函数
		
		function main(cb){
			var obj = 1;
			cb(obj);
		}
		function branch(val){
			if(typeof val !=='number'){
				throw new Error('branch(): argument need number');
			}
			var rslt = 0;
			for(var i = 0;i<1000000000;i++){
				rslt+=i;
			}
		};
		try{
			main(branch);
		}catch(error){
			console.log('err_msg=='+error.message);
		};


		
	</script>
</body>
</html>